// Generated by CoffeeScript 1.6.1
(function() {
  var BUILTIN, CELLS, DNA_DATATYPES, DNA_EXTEND, DNA_ID_PREFIX, DNA_PRIMITIVES, DNA_SUBSCRIBE, FLOAT, FUNCTION, HASHMAP, INTEGER, KEYWORD, Math, NAN, NESTED_EXPR, NULL, PARTIAL_FN, QUOTED_NESTED_EXPR, STRING, THIS, VECTOR, bind_handlers_to_event, bool, complement, compose3, cont_m, cont_t, create_cell, create_cell_by_id, debug, default_handlers_cont, dispatch_handler, dispatch_impl, distinct, domonad, error, find_cell, fun_with_meta, get_arity, get_cell, get_default_protocols, get_method_ns, get_primitive_value_handler, get_protocol, get_value_handler, info, is_array, is_async, is_function, is_just_function, is_nested_expr, is_null, is_object, is_partial_function, is_value, lift, lift_async, lift_sync, logger_m, logger_t, make_dynamic_handler, make_monadized_handler, make_nested_expr, maybe_m, maybe_t, nullog, parse_genome, partial, process_ast_handler_node, process_meta, process_subscribe, process_vector, register_protocol_impl, repeat, save_cell, synthesize_cell, synthesize_node, warn, _ref, _ref1, _ref2, _ref3,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  DNA_EXTEND = 'extend';

  DNA_SUBSCRIBE = 'subscribe';

  DNA_ID_PREFIX = 'Z';

  NAN = 'NaN';

  NULL = 'null';

  KEYWORD = 'keyword';

  STRING = 'string';

  INTEGER = 'integer';

  FLOAT = 'float';

  VECTOR = 'vector';

  HASHMAP = 'hashmap';

  FUNCTION = 'fn';

  PARTIAL_FN = 'partial';

  NESTED_EXPR = 'nested';

  QUOTED_NESTED_EXPR = 'quoted-nested';

  DNA_PRIMITIVES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT];

  DNA_DATATYPES = [NAN, NULL, KEYWORD, STRING, INTEGER, FLOAT, VECTOR, HASHMAP];

  THIS = 'this';

  BUILTIN = '*builtin*';

  Math = require('../utils/Math.uuid');

  _ref = require('libprotein'), partial = _ref.partial, is_array = _ref.is_array, is_object = _ref.is_object, bool = _ref.bool, complement = _ref.complement, compose3 = _ref.compose3, distinct = _ref.distinct, repeat = _ref.repeat;

  parse_genome = (require('genome-parser')).parse;

  _ref1 = require('libprotocol'), register_protocol_impl = _ref1.register_protocol_impl, dispatch_impl = _ref1.dispatch_impl, get_protocol = _ref1.get_protocol, is_async = _ref1.is_async, get_arity = _ref1.get_arity;

  _ref2 = require('libmonad'), cont_t = _ref2.cont_t, cont_m = _ref2.cont_m, maybe_t = _ref2.maybe_t, maybe_m = _ref2.maybe_m, logger_t = _ref2.logger_t, logger_m = _ref2.logger_m, domonad = _ref2.domonad, is_null = _ref2.is_null, lift_sync = _ref2.lift_sync, lift_async = _ref2.lift_async;

  _ref3 = dispatch_impl('ILogger', 'DNA'), info = _ref3.info, warn = _ref3.warn, error = _ref3.error, debug = _ref3.debug, nullog = _ref3.nullog;

  CELLS = {};

  get_default_protocols = function() {
    var _ref4, _ref5;
    return ((_ref4 = require('bootstrapper')) != null ? (_ref5 = _ref4.ENV) != null ? _ref5.DEFAULT_PROTOCOLS : void 0 : void 0) || [];
  };

  process_vector = function(vector, cell, dom_parser, cont) {
    var count, local_cont, res;
    res = [];
    count = vector.length;
    local_cont = function(idx) {
      return function(r) {
        res[idx] = r;
        count--;
        if (count === 0) {
          return cont(res);
        }
      };
    };
    return vector.map(function(ast_node, idx) {
      var c, h;
      h = process_ast_handler_node(cell, dom_parser, ast_node);
      c = local_cont(idx);
      if (h.meta.async) {
        return h.apply(null, (repeat(void 0, h.meta.arity - 1)).concat([c]));
      } else {
        return c(h.apply(null, repeat(void 0, h.meta.arity)));
      }
    });
  };

  default_handlers_cont = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  };

  is_value = function(type) {
    return __indexOf.call(DNA_DATATYPES, type) >= 0;
  };

  is_function = function(type) {
    return type === FUNCTION || type === PARTIAL_FN;
  };

  is_just_function = function(type) {
    return type === FUNCTION;
  };

  is_partial_function = function(type) {
    return type === PARTIAL_FN;
  };

  is_nested_expr = function(type) {
    return type === NESTED_EXPR;
  };

  lift = function(h) {
    if (h.meta.async) {
      return lift_async(h.meta.arity, h);
    } else {
      return lift_sync(h.meta.arity, h);
    }
  };

  get_method_ns = function(name, cell) {
    var method_invariants;
    method_invariants = cell.receptors[name];
    if ((method_invariants != null ? method_invariants.length : void 0) > 0) {
      return method_invariants[0].ns;
    } else {
      error("No such method: " + name + " in the cell:", cell);
      throw "Method missing in cell";
    }
  };

  dispatch_handler = function(ns, name, cell) {
    var handler, method_invariants;
    method_invariants = cell.receptors[name];
    if (method_invariants) {
      handler = method_invariants.length === 1 && !ns ? method_invariants[0] : (cell.receptors[name].filter(function(m) {
        return m.ns === ns;
      }))[0];
      if (handler) {
        return handler.impl;
      } else {
        error("Handler missing", {
          ns: ns,
          name: name,
          cell: cell
        });
        throw "Handler missing";
      }
    } else {
      error("Handler missing", {
        ns: ns,
        name: name,
        cell: cell
      });
      throw "Handler missing";
    }
  };

  save_cell = function(cell) {
    return CELLS[cell.id] = cell;
  };

  get_cell = function(id) {
    return CELLS[id];
  };

  find_cell = function(scope_id, this_cell, dom_parser) {
    var cell;
    if ((scope_id === THIS || !scope_id) && this_cell) {
      return this_cell;
    } else if (cell = get_cell(scope_id)) {
      return cell;
    } else if (cell = create_cell_by_id(scope_id, dom_parser, this_cell.synthesis_id)) {
      return cell;
    } else {
      return null;
    }
  };

  create_cell_by_id = function(id, dom_parser, synthesis_id) {
    var node;
    if (node = dom_parser.get_by_id(id)) {
      return create_cell(dom_parser, synthesis_id, node);
    } else {
      return null;
    }
  };

  fun_with_meta = function(fn, meta) {
    fn.meta = meta;
    return fn;
  };

  get_primitive_value_handler = function(type, value) {
    switch (type) {
      case NAN:
        return fun_with_meta((function() {
          return NaN;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: "NaN"
        });
      case NULL:
        return fun_with_meta((function() {
          return null;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: "null"
        });
      case KEYWORD:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          protocol: BUILTIN,
          name: "Keyword " + value
        });
      case STRING:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "String '" + value + "'"
        });
      case INTEGER:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "Integer '" + value + "'"
        });
      case FLOAT:
        return fun_with_meta((function() {
          return value;
        }), {
          arity: 0,
          async: false,
          ns: BUILTIN,
          name: "Float '" + value + "'"
        });
      default:
        throw "Unknown primitive type: " + type + "/" + value;
    }
  };

  get_value_handler = function(type, value, cell, dom_parser) {
    switch (type) {
      case NAN:
      case NULL:
      case KEYWORD:
      case STRING:
      case INTEGER:
      case FLOAT:
        return get_primitive_value_handler(type, value);
      case VECTOR:
        return fun_with_meta(function(cont) {
          return process_vector(value, cell, dom_parser, function(res) {
            return cont(res);
          });
        }, {
          async: true,
          arity: 1,
          protocol: BUILTIN,
          name: "Vector"
        });
      case HASHMAP:
        return fun_with_meta(function(key) {
          if (key) {
            return value[key];
          } else {
            return value;
          }
        }, {
          arity: 1,
          async: false,
          protocol: BUILTIN,
          name: "Hashmap"
        });
      default:
        throw "Unknown type: " + type;
    }
  };

  make_nested_expr = function(dom_parser, current_cell, handler) {
    return fun_with_meta(function(arg, cont) {
      var f;
      f = make_monadized_handler(dom_parser, current_cell, cont, handler);
      return f(arg);
    }, {
      async: true,
      arity: 2,
      protocol: BUILTIN,
      name: NESTED_EXPR
    });
  };

  process_ast_handler_node = function(current_cell, dom_parser, handler) {
    var USE_LAZY_PARTIAL_ARGS, arity, h, vargs, _get_cell, _ref4;
    _get_cell = function(id) {
      var cell;
      cell = find_cell(id, current_cell, dom_parser);
      if (!cell) {
        error("Unknown cell referenced in handler", id, handler);
        throw "Unknown cell referenced in handler";
      }
      return cell;
    };
    switch (handler.type) {
      case FUNCTION:
        return dispatch_handler(handler.ns, handler.name, _get_cell(handler.scope || THIS));
      case PARTIAL_FN:
        USE_LAZY_PARTIAL_ARGS = true;
        h = dispatch_handler(handler.fn.ns, handler.fn.name, _get_cell(handler.fn.scope || THIS));
        if (USE_LAZY_PARTIAL_ARGS) {
          _ref4 = h.meta, vargs = _ref4.vargs, arity = _ref4.arity;
          return fun_with_meta(function() {
            var accepted_args, args;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            accepted_args = args.slice(0, arity);
            return process_vector(handler.args, current_cell, dom_parser, function(calculated_args) {
              var cont, raw_accepted_args, _i;
              if (h.meta.async) {
                return h.apply(null, calculated_args.concat(accepted_args));
              } else {
                raw_accepted_args = 2 <= accepted_args.length ? __slice.call(accepted_args, 0, _i = accepted_args.length - 1) : (_i = 0, []), cont = accepted_args[_i++];
                return cont(h.apply(null, calculated_args.concat(raw_accepted_args)));
              }
            });
          }, {
            arity: arity,
            async: true,
            name: "partial application of " + h.meta.name,
            protocol: h.meta.protocol
          });
        } else {
          return partial.apply(null, [h].concat(__slice.call(handler.args.map(function(_arg) {
            var type, value;
            type = _arg.type, value = _arg.value;
            if (__indexOf.call(DNA_PRIMITIVES, type) < 0) {
              throw "Only primitive datatypes accepted as partial args";
            }
            return (get_primitive_value_handler(type, value))();
          }))));
        }
        break;
      case NESTED_EXPR:
        return make_nested_expr(dom_parser, current_cell, handler.value);
      case QUOTED_NESTED_EXPR:
        throw "QUOTED_NESTED_EXPR is not implemented yet";
        break;
      case NAN:
      case NULL:
      case KEYWORD:
      case STRING:
      case INTEGER:
      case FLOAT:
      case VECTOR:
      case HASHMAP:
        return get_value_handler(handler.type, handler.value, _get_cell(handler.scope || THIS), dom_parser);
      default:
        error("Unknown expression type: " + handler.type, handler);
        throw "Unknown expression type: " + handler.type;
    }
  };

  process_meta = function(cell, h) {
    return h;
  };

  make_monadized_handler = function(dom_parser, cell, cont, handlr) {
    var ast_parser, do_meta, lifted_handlers_chain, wrapper_monad;
    ast_parser = partial(process_ast_handler_node, cell, dom_parser);
    do_meta = partial(process_meta, cell);
    lifted_handlers_chain = handlr.seq.map(compose3(lift, do_meta, ast_parser));
    wrapper_monad = cont_t(logger_t(maybe_m({
      is_error: is_null
    }), nullog));
    return fun_with_meta(function(init_val) {
      return (domonad(wrapper_monad, lifted_handlers_chain, init_val))(cont);
    }, {
      async: true,
      arity: 1,
      name: 'monadized-handler'
    });
  };

  bind_handlers_to_event = function(dom_parser, cell, handlers, event_node) {
    var args, event_binder, name, ns, scope, type, _ref4;
    _ref4 = event_node.type === 'partial-event' ? {
      type: 'partial-event',
      args: event_node.args.map(partial(process_ast_handler_node, cell, dom_parser)),
      name: event_node.event.name,
      ns: event_node.event.ns,
      scope: event_node.event.scope
    } : {
      type: 'event',
      args: [],
      name: event_node.name,
      ns: event_node.ns,
      scope: event_node.scope
    }, type = _ref4.type, args = _ref4.args, name = _ref4.name, ns = _ref4.ns, scope = _ref4.scope;
    event_binder = dispatch_handler(ns, name, find_cell(scope || THIS, cell, dom_parser));
    return handlers.map(function(handlr) {
      return event_binder.apply(null, args.concat([handlr]));
    });
  };

  make_dynamic_handler = function(dom_parser, cell, cont, handlr) {
    return function() {
      var args, fresh_cell, h;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      fresh_cell = find_cell(cell.id, cell, dom_parser);
      h = make_monadized_handler(dom_parser, fresh_cell, cont, handlr);
      return h.apply(null, args);
    };
  };

  process_subscribe = function(cell) {
    var genes, genome_string;
    if (cell.subscriptions_processed) {
      return;
    }
    cell.subscriptions_processed = true;
    genome_string = cell.dom_parser.getData(DNA_SUBSCRIBE, cell.node);
    if (bool(genome_string)) {
      genes = parse_genome(genome_string);
      return genes.map(function(gene) {
        return gene.events.map(partial(bind_handlers_to_event, cell.dom_parser, cell, gene.handlers.map(partial(make_dynamic_handler, cell.dom_parser, cell, default_handlers_cont))));
      });
    }
  };

  synthesize_cell = function(node, dom_parser, synthesis_id) {
    var all_the_protocols, extended_protocols, proto_cell;
    if (!node.id) {
      node.id = (dom_parser.get_id(node)) || DNA_ID_PREFIX + Math.uuid();
    }
    proto_cell = {
      id: node.id,
      node: node,
      receptors: {},
      impls: {},
      dom_parser: dom_parser,
      synthesis_id: synthesis_id
    };
    extended_protocols = (extended_protocols = dom_parser.getData(DNA_EXTEND, node)) ? (extended_protocols.split(' ')).filter(function(i) {
      return !!i;
    }) : [];
    all_the_protocols = distinct(extended_protocols.concat(get_default_protocols()));
    all_the_protocols.map(function(protocol) {
      var p;
      p = get_protocol(protocol);
      proto_cell.impls[protocol] = dispatch_impl(protocol, node);
      if (p && proto_cell.impls[protocol]) {
        return p.map(function(_arg) {
          var args, m, name;
          name = _arg[0], args = _arg[1];
          m = {
            name: name,
            ns: protocol,
            impl: proto_cell.impls[protocol][name]
          };
          if (proto_cell.receptors[name]) {
            return proto_cell.receptors[name].push(m);
          } else {
            return proto_cell.receptors[name] = [m];
          }
        });
      }
    });
    return proto_cell;
  };

  create_cell = function(dom_parser, synthesis_id, node) {
    var cell, maybe_id, old_cell, sid;
    maybe_id = node.id;
    sid = maybe_id && (old_cell = get_cell(maybe_id)) ? (debug("Reinstantiating cell with id " + maybe_id), old_cell.synthesis_id + 1) : synthesis_id;
    cell = synthesize_cell(node, dom_parser, sid);
    save_cell(cell);
    return cell;
  };

  synthesize_node = function(dom_parser) {
    var START_TIME, active_nodes, creator, new_cells, root_node, synthesis_id;
    START_TIME = new Date;
    synthesis_id = 0;
    root_node = dom_parser.get_root_node();
    active_nodes = dom_parser.get_by_attr("[data-" + DNA_EXTEND + "], [data-" + DNA_SUBSCRIBE + "], [id]");
    creator = partial(create_cell, dom_parser, synthesis_id);
    new_cells = active_nodes.map(function(node) {
      return creator(node);
    });
    return new_cells.map(function(cell) {
      return process_subscribe(cell);
    });
  };

  module.exports = {
    get_cells: function() {
      return CELLS;
    },
    get_cell: get_cell,
    start_synthesis: function(root_node) {
      var root_idom;
      if (!root_node) {
        error("Root node not specified");
        throw "Root node not specified";
      }
      info('Synthesis started');
      root_idom = dispatch_impl('IDom', root_node);
      root_idom.add_event_listener("DOMNodeInserted", function(event) {
        return setTimeout(function() {
          return synthesize_node(dispatch_impl('IDom', event.target));
        }, 10);
      });
      return synthesize_node(root_idom);
    },
    dump_cells: function() {
      return info('Cells synthesized for this document:', CELLS);
    }
  };

}).call(this);
