// Generated by CoffeeScript 1.6.1
(function() {
  var CONS, THIS, bt, debug, discover_protocols, dispatch_impl, dump_impls, error, get_arity, get_meta, get_meta_key, get_method, get_protocol, info, is_array, is_async, is_vararg, partial, register_protocol, register_protocol_impl, warn, _ref, _ref1,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  _ref = require('console-logger'), info = _ref.info, warn = _ref.warn, error = _ref.error, debug = _ref.debug;

  bt = require('bootstrapper');

  bt.PROTO || (bt.PROTO = {
    Implementations: {},
    Protocols: {}
  });

  THIS = 'this';

  CONS = '*cons*';

  _ref1 = require('libprotein'), partial = _ref1.partial, is_array = _ref1.is_array;

  get_protocol = function(p) {
    if (bt.PROTO.Protocols.hasOwnProperty(p)) {
      return bt.PROTO.Protocols[p];
    } else {
      throw "No such registered protocol: '" + p + "'";
    }
  };

  register_protocol = function(name, p) {
    if (!bt.PROTO.Protocols.hasOwnProperty(p)) {
      return bt.PROTO.Protocols[name] = p;
    } else {
      throw "Such protocol is already registered: '" + name + "'";
    }
  };

  get_method = function(ns, method_name) {
    var m, _ref2;
    m = (_ref2 = bt.PROTO.Protocols[ns]) != null ? _ref2.filter(function(_arg) {
      var mn;
      mn = _arg[0];
      return mn === method_name;
    }) : void 0;
    if (m.length === 1) {
      return m[0];
    } else {
      error("No such method:", ns, method_name);
      throw "No such method";
    }
  };

  get_meta = function(ns, method_name) {
    var meta, _, _ref2;
    _ref2 = get_method(ns, method_name), _ = _ref2[0], _ = _ref2[1], meta = _ref2[2];
    return meta || {};
  };

  get_meta_key = function(prop, ns, method_name) {
    return (get_meta(ns, method_name))[prop];
  };

  is_async = partial(get_meta_key, 'async');

  is_vararg = partial(get_meta_key, 'vararg');

  get_arity = function(ns, method_name) {
    var argums, _, _ref2;
    _ref2 = get_method(ns, method_name), _ = _ref2[0], argums = _ref2[1], _ = 3 <= _ref2.length ? __slice.call(_ref2, 2) : [];
    return argums.length;
  };

  register_protocol_impl = function(protocol, impl) {
    if (!get_protocol(protocol)) {
      throw "Can't register implementation for an unknown protocol: '" + protocol + "'";
    }
    if (!bt.PROTO.Implementations.hasOwnProperty(protocol)) {

    } else {

    }
    return bt.PROTO.Implementations[protocol] = impl;
  };

  discover_protocols = function() {
    var bootstrapper, definition, exports, impl, modname, protocol, _ref2, _ref3, _ref4, _results;
    bootstrapper = require('bootstrapper');
    _results = [];
    for (modname in bootstrapper.modules) {
      exports = require(modname);
      if ((_ref2 = exports.protocols) != null ? _ref2.definitions : void 0) {
        _ref3 = exports.protocols.definitions;
        for (protocol in _ref3) {
          definition = _ref3[protocol];
          register_protocol(protocol, definition);
        }
      }
      if ((_ref4 = exports.protocols) != null ? _ref4.implementations : void 0) {
        _results.push((function() {
          var _ref5, _results1;
          _ref5 = exports.protocols.implementations;
          _results1 = [];
          for (protocol in _ref5) {
            impl = _ref5[protocol];
            _results1.push(register_protocol_impl(protocol, impl));
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  dispatch_impl = function(protocol, opts) {
    var concerns, cons, f, fun, k, meta, name, q, v, xopts, _i, _len, _ref2, _ref3, _ref4;
    if (opts == null) {
      opts = void 0;
    }
    if (!(bt.PROTO.Protocols[protocol] && bt.PROTO.Implementations[protocol])) {
      discover_protocols();
    }
    if (bt.PROTO.Protocols[protocol] && bt.PROTO.Implementations[protocol]) {
      cons = bt.PROTO.Protocols[protocol].filter(function(m) {
        return m[0] === CONS;
      })[0];
      if (cons) {
        meta = get_meta(protocol, CONS);
        if ((_ref2 = meta.concerns) != null ? _ref2.before : void 0) {
          concerns = is_array(meta.concerns.before) ? meta.concerns.before : [meta.concerns.before];
          xopts = [opts];
          for (_i = 0, _len = concerns.length; _i < _len; _i++) {
            f = concerns[_i];
            xopts.push(f.apply(null, xopts));
          }
          opts = xopts;
        }
      }
      q = (_ref3 = bt.PROTO.Implementations)[protocol].apply(_ref3, (is_array(opts) ? opts : [opts]));
      for (name in q) {
        if (!__hasProp.call(q, name)) continue;
        fun = q[name];
        fun.meta || (fun.meta = {});
        fun.meta.name = name;
        fun.meta.protocol = protocol;
        fun.meta.arity = get_arity(protocol, name);
        _ref4 = get_meta(protocol, name);
        for (k in _ref4) {
          v = _ref4[k];
          fun.meta[k] = v;
        }
      }
      return q;
    } else {
      debug("Cant find implementations for protocol " + protocol);
      return null;
    }
  };

  dump_impls = function() {
    return debug("Currently registered bt.PROTO.Implementations:", bt.PROTO.Implementations);
  };

  module.exports = {
    register_protocol_impl: register_protocol_impl,
    register_protocol: register_protocol,
    get_protocol: get_protocol,
    dispatch_impl: dispatch_impl,
    dump_impls: dump_impls,
    is_async: is_async,
    is_vararg: is_vararg,
    get_arity: get_arity,
    discover_protocols: discover_protocols
  };

}).call(this);
