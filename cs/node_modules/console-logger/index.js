// Generated by CoffeeScript 1.6.0
(function() {
  var DEBUG, ERROR, INFO, LOGCFG, LOG_LEVELS, NOTICE, UNK_NS, WARN, and_, bool, bt, get_namespaced_logger, is_array, is_object, log, log_level_enabled, log_ns_enabled, nullog, or_, partial, root, say, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  root = typeof process !== "undefined" && process !== null ? process : typeof window !== "undefined" && window !== null ? window : {};

  if (!root.console) {
    root.console = {
      log: function() {},
      info: function() {},
      warn: function() {},
      error: function() {},
      assert: function() {},
      dir: function() {},
      clear: function() {},
      profile: function() {},
      profileEnd: function() {}
    };
  }

  if (Function.prototype.bind && console && typeof console.log == "object") {
    [
      "log","info","warn","error","assert","dir","clear","profile","profileEnd"
    ].forEach(function (method) {
        console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
};

  _ref = require('libprotein'), partial = _ref.partial, or_ = _ref.or_, and_ = _ref.and_, bool = _ref.bool, is_object = _ref.is_object, is_array = _ref.is_array;

  LOGCFG = (function() {
    try {
      bt = require('bootstrapper');
      if (bt && (is_object(bt.ENV)) && (is_object(bt.ENV.LOG))) {
        return bt.ENV.LOG;
      } else {
        return null;
      }
    } catch (e) {
      if ((typeof process !== "undefined" && process !== null) && (is_object(process.ENV)) && (is_object(process.ENV.LOG))) {
        return process.ENV.LOG;
      } else if ((typeof window !== "undefined" && window !== null) && (is_object(window.ENV)) && (is_object(window.ENV.LOG))) {
        return window.ENV.LOG;
      } else {
        return null;
      }
    }
  })();

  try {
    if ((typeof window !== "undefined" && window !== null) && LOGCFG) {
      window.logger_mute_ns_except = function(exp) {
        var k, _results;
        if (exp && !is_array(exp)) {
          exp = [exp];
        }
        _results = [];
        for (k in LOGCFG.ns) {
          _results.push(LOGCFG.ns[k] = __indexOf.call(exp, k) >= 0 ? true : false);
        }
        return _results;
      };
      window.logger_unmute_ns = function() {
        var k, _results;
        _results = [];
        for (k in LOGCFG.ns) {
          _results.push(LOGCFG.ns[k] = true);
        }
        return _results;
      };
      window.logger_mute_ns = function() {
        var k, _results;
        _results = [];
        for (k in LOGCFG.ns) {
          _results.push(LOGCFG.ns[k] = false);
        }
        return _results;
      };
      window.logger_unmute_level = function() {
        var k, _results;
        _results = [];
        for (k in LOGCFG.level) {
          _results.push(LOGCFG.level[k] = true);
        }
        return _results;
      };
      window.logger_mute_level = function() {
        var k, _results;
        _results = [];
        for (k in LOGCFG.level) {
          _results.push(LOGCFG.level[k] = false);
        }
        return _results;
      };
    }
  } catch (e) {
    null;
  }

  INFO = 'INFO';

  WARN = 'WARN';

  ERROR = 'ERROR';

  DEBUG = 'DEBUG';

  NOTICE = 'NOTICE';

  LOG_LEVELS = [INFO, WARN, ERROR, DEBUG, NOTICE];

  UNK_NS = 'UNK_NS';

  say = function(log_level, log_ns, msgs) {
    var m;
    m = [(log_level ? "[" + log_level + "]" : '[NOTICE]'), (log_ns ? "[" + log_ns + "]" : "[" + UNK_NS + "]")].concat(msgs);
    switch (log_level) {
      case ERROR:
        return typeof console !== "undefined" && console !== null ? typeof console.error === "function" ? console.error.apply(console, m) : void 0 : void 0;
      case INFO:
        return typeof console !== "undefined" && console !== null ? console.info.apply(console, m) : void 0;
      case DEBUG:
        if ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null) {
          return typeof console !== "undefined" && console !== null ? console.debug.apply(console, m) : void 0;
        } else {
          return typeof console !== "undefined" && console !== null ? console.log.apply(console, m) : void 0;
        }
        break;
      case WARN:
        return typeof console !== "undefined" && console !== null ? console.warn.apply(console, m) : void 0;
      default:
        return typeof console !== "undefined" && console !== null ? console.log.apply(console, m) : void 0;
    }
  };

  log_level_enabled = function(log_level) {
    var _ref1;
    if (LOGCFG) {
      return ((_ref1 = LOGCFG.level) != null ? _ref1[log_level] : void 0) === true;
    } else {
      return true;
    }
  };

  log_ns_enabled = function(log_ns) {
    var _ref1;
    if (LOGCFG) {
      return ((_ref1 = LOGCFG.ns) != null ? _ref1[log_ns] : void 0) === true;
    } else {
      return false;
    }
  };

  log = function() {
    var enabled, k, log_level, log_ns, msg, ns_keys, v;
    log_level = arguments[0], log_ns = arguments[1], msg = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    ns_keys = (function() {
      var _ref1, _results;
      _ref1 = LOGCFG.ns;
      _results = [];
      for (k in _ref1) {
        v = _ref1[k];
        _results.push(k);
      }
      return _results;
    })();
    enabled = LOGCFG.enabled != null ? LOGCFG.enabled : true;
    if (!enabled) {
      return;
    }
    if (ns_keys.length) {
      if (log_ns_enabled(log_ns) && (log_level_enabled(log_level))) {
        return say(log_level, log_ns, msg);
      }
    } else {
      if (log_level_enabled(log_level)) {
        return say(log_level, log_ns, msg);
      }
    }
  };

  nullog = function() {};

  get_namespaced_logger = function(log_ns) {
    return {
      info: partial(log, INFO, log_ns),
      warn: partial(log, WARN, log_ns),
      error: partial(log, ERROR, log_ns),
      debug: partial(log, DEBUG, log_ns),
      notice: partial(log, NOTICE, log_ns),
      nullog: nullog
    };
  };

  module.exports = {
    info: partial(log, INFO, UNK_NS),
    warn: partial(log, WARN, UNK_NS),
    error: partial(log, ERROR, UNK_NS),
    debug: partial(log, DEBUG, UNK_NS),
    notice: partial(log, NOTICE, UNK_NS),
    nullog: nullog,
    ns: get_namespaced_logger,
    protocols: {
      definitions: {
        ILogger: [
          [
            'info', [], {
              varargs: true
            }
          ], [
            'warn', [], {
              varargs: true
            }
          ], [
            'error', [], {
              varargs: true
            }
          ], [
            'debug', [], {
              varargs: true
            }
          ], [
            'notice', [], {
              varargs: true
            }
          ], [
            'nullog', [], {
              varargs: true
            }
          ]
        ]
      },
      implementations: {
        ILogger: get_namespaced_logger
      }
    }
  };

}).call(this);
